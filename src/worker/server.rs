use futures::{future, prelude::*};
use mapreduce::configuration::get_configuration;
use mapreduce::worker::Worker;
use mapreduce::worker::WorkerService;
use std::net::IpAddr;
use tarpc::{
    server::{self, Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};

#[derive(Clone)]
struct WorkerServer(Worker, pub (IpAddr, u16));

impl WorkerServer {
    pub fn new(host: IpAddr, port: u16) -> Self {
        WorkerServer(Worker::new(), (host, port))
    }
}

impl WorkerService for WorkerServer {
    async fn ping(self, _context: tarpc::context::Context) -> bool {
        let id = self.0.id();
        println!("Master pinged me how special I am with id = {:?}", id);
        true
    }
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let config = get_configuration().expect("Failed to read config");
    let worker_server = WorkerServer::new(config.rpc.get_host(), config.rpc.port);
    let server_addr = worker_server.1;
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            channel
                .execute(worker_server.clone().serve())
                .for_each(spawn)
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}
