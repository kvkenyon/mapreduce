//! src/workers/lib.rs
use crate::configuration::Settings;
use crate::master::{MapTask, ReduceTask};
use crate::worker::WorkerService;
use futures::{future, prelude::*};
use tarpc::{
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use uuid::Uuid;

#[derive(Clone, PartialEq, Debug)]
pub struct WorkerId(Uuid);

impl WorkerId {
    pub fn new() -> Self {
        WorkerId(Uuid::new_v4())
    }

    pub fn id(&self) -> Uuid {
        self.0
    }
}

impl Default for WorkerId {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Clone, Debug)]
pub struct Worker {
    id: WorkerId,
    map_tasks: Vec<MapTask>,
    reduce_tasks: Vec<ReduceTask>,
}

impl Default for Worker {
    fn default() -> Self {
        Self::new()
    }
}

impl Worker {
    pub fn new() -> Self {
        Self {
            id: WorkerId::new(),
            map_tasks: vec![],
            reduce_tasks: vec![],
        }
    }

    pub fn id(&self) -> &WorkerId {
        &self.id
    }

    pub fn run(&mut self) -> Result<(), anyhow::Error> {
        Ok(())
    }

    pub fn assign_map(&mut self, task: MapTask) -> Result<(), anyhow::Error> {
        self.map_tasks.push(task);
        Ok(())
    }

    pub fn assign_reduce(&mut self, task: ReduceTask) -> Result<(), anyhow::Error> {
        self.reduce_tasks.push(task);
        Ok(())
    }

    pub fn has_task(&self) -> bool {
        !self.map_tasks.is_empty() || !self.reduce_tasks.is_empty()
    }
}

#[derive(Clone)]
pub struct WorkerServer {
    worker: Worker,
    host: String,
    port: u16,
}

impl WorkerServer {
    pub async fn build(config: Settings) -> anyhow::Result<Self> {
        let worker_server = WorkerServer {
            host: config.rpc.host,
            port: config.rpc.port,
            worker: Worker::new(),
        };
        Ok(worker_server)
    }

    pub async fn run_until_stopped(&self) -> anyhow::Result<()> {
        let server_addr = format!("{}:{}", self.host, self.port);
        let mut listener = tarpc::serde_transport::tcp::listen(server_addr, Json::default).await?;
        listener.config_mut().max_frame_length(usize::MAX);
        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| channel.execute(self.clone().serve()).for_each(spawn))
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;
        Ok(())
    }
}

impl WorkerService for WorkerServer {
    async fn ping(self, _context: tarpc::context::Context) -> bool {
        let id = self.worker.id();
        println!("Master pinged me how special I am with id = {:?}", id);
        true
    }
}
async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}
