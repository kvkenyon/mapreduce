//! src/workers/lib.rs
use crate::configuration::Settings;
use crate::master::{MapTask, MasterServiceClient, ReduceTask};
use crate::worker::{WorkerService, WorkerStatus};
use anyhow::Context;
use futures::{future, prelude::*};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use tarpc::{
    server::{self, Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};
use tokio::sync::oneshot;
use tokio::task::JoinHandle;
use uuid::Uuid;

#[derive(Clone, PartialEq, Debug, serde::Serialize, serde::Deserialize)]
pub struct WorkerId(Uuid);

impl WorkerId {
    pub fn new() -> Self {
        WorkerId(Uuid::new_v4())
    }

    pub fn id(&self) -> Uuid {
        self.0
    }
}

impl Default for WorkerId {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Clone, Debug)]
pub struct Worker {
    id: WorkerId,
    map_tasks: Vec<MapTask>,
    reduce_tasks: Vec<ReduceTask>,
    master_service_client: Option<MasterServiceClient>,
}

impl Default for Worker {
    fn default() -> Self {
        Self::new()
    }
}

impl Worker {
    pub fn new() -> Self {
        Self {
            id: WorkerId::new(),
            map_tasks: vec![],
            reduce_tasks: vec![],
            master_service_client: None,
        }
    }

    pub fn id(&self) -> &WorkerId {
        &self.id
    }

    pub fn run(&mut self) -> Result<(), anyhow::Error> {
        Ok(())
    }

    pub fn assign_map(&mut self, task: MapTask) -> Result<(), anyhow::Error> {
        self.map_tasks.push(task);
        Ok(())
    }

    pub fn assign_reduce(&mut self, task: ReduceTask) -> Result<(), anyhow::Error> {
        self.reduce_tasks.push(task);
        Ok(())
    }

    pub fn has_task(&self) -> bool {
        !self.map_tasks.is_empty() || !self.reduce_tasks.is_empty()
    }

    pub fn set_master_service_client(&mut self, master_service_client: MasterServiceClient) {
        self.master_service_client = Some(master_service_client);
    }
}

#[derive(Debug, Clone)]
pub struct WorkerServer {
    worker: Worker,
    host: String,
    port: u16,
}

impl WorkerServer {
    pub async fn build(config: Settings) -> anyhow::Result<Self> {
        let worker_server = WorkerServer {
            host: config.rpc.host,
            port: config.rpc.port,
            worker: Worker::new(),
        };
        Ok(worker_server)
    }

    #[tracing::instrument("WorkerServer start", skip_all)]
    pub async fn start(
        &self,
        shutdown_tx: &tokio::sync::broadcast::Sender<()>,
    ) -> anyhow::Result<(SocketAddr, JoinHandle<anyhow::Result<()>>)> {
        let (addr_tx, addr_rx) = oneshot::channel::<SocketAddr>();

        let socket_addr = self.get_addr().context("Failed to get address")?;

        let mut shutdown_rx = shutdown_tx.subscribe();
        let server_clone = self.clone();
        let handle = tokio::spawn(async move {
            tokio::select! {
                result = Self::run_until_stopped(&socket_addr, addr_tx, server_clone) => {
                    result
                }
                _ = shutdown_rx.recv() => {
                    tracing::info!("Worker shutting down");
                   Ok(())
                }
            }
        });
        tracing::info!("waiting for bound socket addr.");
        let socket_addr = addr_rx.await.context("Failed to receive worker address")?;
        Ok((socket_addr, handle))
    }

    #[tracing::instrument("Run worker until stopped", skip_all)]
    async fn run_until_stopped(
        server_addr: &SocketAddr,
        addr_tx: oneshot::Sender<SocketAddr>,
        worker_server: WorkerServer,
    ) -> anyhow::Result<()> {
        let mut listener = tarpc::serde_transport::tcp::listen(server_addr, Json::default).await?;
        listener.config_mut().max_frame_length(usize::MAX);
        let socket_addr = listener.local_addr();
        let _ = addr_tx.send(socket_addr);
        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| channel.execute(worker_server.clone().serve()).for_each(spawn))
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;
        Ok(())
    }

    pub fn host(&self) -> &str {
        &self.host
    }

    pub fn port(&self) -> u16 {
        self.port
    }

    pub fn get_addr(&self) -> anyhow::Result<SocketAddr> {
        let addr: Ipv4Addr = self.host().parse().context("Failed to parse host")?;
        Ok(SocketAddr::new(IpAddr::V4(addr), self.port))
    }

    pub fn worker(&mut self) -> &mut Worker {
        &mut self.worker
    }
}

impl WorkerService for WorkerServer {
    async fn ping(self, _context: tarpc::context::Context) -> bool {
        let id = self.worker.id();
        println!("Master pinged me how special I am with id = {:?}", id);
        true
    }

    async fn status(self, _context: tarpc::context::Context) -> WorkerStatus {
        WorkerStatus::Idle(self.worker.id)
    }
}
async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}
