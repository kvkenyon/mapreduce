//! src/workers/lib.rs

use crate::configuration::Settings;
use crate::master::{CallHome, MapTask, MasterServiceClient, ReduceTask};
use crate::worker::{WorkerService, WorkerServiceError, WorkerStatus};
use anyhow::{Context, anyhow};
use futures::{future, prelude::*};
use std::fmt::Formatter;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::Arc;
use tarpc::{
    context,
    server::{self, Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};
use tokio::sync::RwLock;
use tokio::sync::oneshot;
use tokio::task::JoinHandle;
use uuid::Uuid;

#[derive(Clone, PartialEq, Debug, serde::Serialize, serde::Deserialize, Eq, Hash, Copy)]
pub struct WorkerId(Uuid);

impl std::fmt::Display for WorkerId {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{}", self.0)
    }
}

impl WorkerId {
    pub fn new() -> Self {
        WorkerId(Uuid::new_v4())
    }

    pub fn id(&self) -> Uuid {
        self.0
    }
}

impl Default for WorkerId {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Clone, Debug)]
pub struct Worker {
    id: WorkerId,
    map_tasks: Arc<RwLock<Vec<MapTask>>>,
    reduce_tasks: Arc<RwLock<Vec<ReduceTask>>>,
    master_service_client: Option<MasterServiceClient>,
}

impl Default for Worker {
    fn default() -> Self {
        Self::new()
    }
}

impl Worker {
    pub fn new() -> Self {
        Self {
            id: WorkerId::new(),
            map_tasks: Arc::new(RwLock::new(vec![])),
            reduce_tasks: Arc::new(RwLock::new(vec![])),
            master_service_client: None,
        }
    }

    pub fn id(&self) -> &WorkerId {
        &self.id
    }

    pub fn run(&mut self) -> Result<(), anyhow::Error> {
        Ok(())
    }

    pub async fn assign_map(&mut self, task: MapTask) -> Result<(), anyhow::Error> {
        self.map_tasks.write().await.push(task);
        Ok(())
    }

    pub async fn assign_reduce(&mut self, task: ReduceTask) -> Result<(), anyhow::Error> {
        self.reduce_tasks.write().await.push(task);
        Ok(())
    }

    pub async fn has_task(&self) -> bool {
        !self.map_tasks.read().await.is_empty() || !self.reduce_tasks.read().await.is_empty()
    }

    pub fn set_master_service_client(&mut self, master_service_client: MasterServiceClient) {
        self.master_service_client = Some(master_service_client);
    }
}

#[derive(Debug, Clone)]
pub struct WorkerServer {
    worker: Worker,
    host: String,
    port: u16,
    socket_addr: Option<SocketAddr>,
}

impl WorkerServer {
    pub async fn build(config: Settings) -> anyhow::Result<Self> {
        let worker_server = WorkerServer {
            host: config.rpc.host,
            port: config.rpc.port,
            worker: Worker::new(),
            socket_addr: None,
        };
        Ok(worker_server)
    }

    #[tracing::instrument("WorkerServer start", skip_all)]
    pub async fn start(
        &mut self,
        shutdown_tx: &tokio::sync::broadcast::Sender<()>,
    ) -> anyhow::Result<(SocketAddr, JoinHandle<anyhow::Result<()>>)> {
        let (addr_tx, addr_rx) = oneshot::channel::<SocketAddr>();

        let socket_addr = self.get_addr().context("Failed to get address")?;

        let mut shutdown_rx = shutdown_tx.subscribe();
        let server_clone = self.clone();
        let handle = tokio::spawn(async move {
            tokio::select! {
                result = Self::run_until_stopped(&socket_addr, addr_tx, server_clone) => {
                    result
                }
                _ = shutdown_rx.recv() => {
                    tracing::info!("Worker shutting down");
                   Ok(())
                }
            }
        });
        tracing::info!("waiting to bind socket address");
        let socket_addr = addr_rx.await.context("Failed to receive worker address")?;
        self.socket_addr = Some(socket_addr);
        tracing::info!("socket address acquired: {socket_addr}");
        Ok((socket_addr, handle))
    }

    #[tracing::instrument("Run worker until stopped", skip_all)]
    async fn run_until_stopped(
        server_addr: &SocketAddr,
        addr_tx: oneshot::Sender<SocketAddr>,
        worker_server: WorkerServer,
    ) -> anyhow::Result<()> {
        let mut listener = tarpc::serde_transport::tcp::listen(server_addr, Json::default).await?;
        listener.config_mut().max_frame_length(usize::MAX);
        let socket_addr = listener.local_addr();
        let _ = addr_tx.send(socket_addr);
        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                channel
                    .execute(worker_server.clone().serve())
                    .for_each(spawn)
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;
        Ok(())
    }

    pub fn host(&self) -> &str {
        &self.host
    }

    pub fn port(&self) -> u16 {
        self.port
    }

    pub fn get_addr(&self) -> anyhow::Result<SocketAddr> {
        let addr: Ipv4Addr = self.host().parse().context("Failed to parse host")?;
        Ok(SocketAddr::new(IpAddr::V4(addr), self.port))
    }

    pub fn worker(&mut self) -> &mut Worker {
        &mut self.worker
    }

    #[tracing::instrument("Worker call home", skip_all, fields(
        worker_id=%self.worker.id(),
    ))]
    pub async fn call_home(&self) -> anyhow::Result<bool> {
        let worker_id = self.worker.id();
        let socket_addr = self.socket_addr;

        if socket_addr.is_none() {
            return Err(anyhow!(
                "Socket address is None, cannot call home to master"
            ));
        }

        let socket_addr = socket_addr.unwrap();

        let call_home = CallHome::WorkerResponse(*worker_id, socket_addr);
        self.worker
            .master_service_client
            .as_ref()
            .unwrap()
            .call_home(context::current(), call_home)
            .await
            .context("Failed to call home")
    }
}

impl WorkerService for WorkerServer {
    async fn ping(self, _context: context::Context) -> bool {
        let id = self.worker.id();
        println!("Master pinged me how special I am with id = {:?}", id);
        true
    }

    async fn status(self, _context: context::Context) -> WorkerStatus {
        WorkerStatus::Idle(self.worker.id)
    }

    async fn assign_map_task(
        mut self,
        _: context::Context,
        map_task: MapTask,
    ) -> Result<bool, WorkerServiceError> {
        self.worker
            .assign_map(map_task)
            .await
            .context("Failed to assign map task")?;
        Ok(true)
    }

    async fn assign_reduce_task(
        mut self,
        _: context::Context,
        reduce_task: ReduceTask,
    ) -> Result<bool, WorkerServiceError> {
        self.worker
            .assign_reduce(reduce_task)
            .await
            .context("Failed to assign reduce task")?;
        Ok(true)
    }
}
async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}
